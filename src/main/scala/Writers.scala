package com.superfell.wsdl

//import scala.xml._
import java.io._

// Helper class for generating a new source code file.
class SourceWriter(val file: File) {
  val w = new PrintWriter(file)
  var numIndent = 0
  var indentStr = ""

  def indent() {
    numIndent += 1
    indentStr = "\t" * numIndent
  }

  def outdent() {
    numIndent -= 1
    indentStr = "\t" * numIndent
  }

  def close() {
    w.close()
  }

  def println() {
    w.println()
  }

  def println(s: String) {
    s.split("\n").map(indentStr + _).foreach(w.println)
  }

  // for the collection of types, adds any import statements that would be needed.
  def printImports(types: Iterable[TypeInfo]) {
    val imports = types.map({
      _ match {
        case a: ArrayTypeInfo =>
          if (a.componentType.isGeneratedType) a.componentType.objcName + ".h"
          else ""
        case t: TypeInfo => if (t.isGeneratedType) t.objcName + ".h" else ""
      }
    })
    val ts = collection.immutable.TreeSet.empty[String]
    val its = ts ++ imports
    for (t <- its.filter(_.length > 0))
      printImport(t)
  }

  def printImport(f: String) {
    println(s"""#import "$f"""")
  }

  def printClassForwardDecl(c: String) {
    println(s"@class $c;")
  }

  def printProtocolForwardDecl(p: String) {
    println(s"@protocol $p;")
  }

  // reads the first line of the copyright from the current matching source file in the zkSforce tree, if it exists.
  private def getOriginalCopyright(file: File): String = {
    val src = new File(
      file.getParentFile(),
      "../../../zkSforce/zkSforce/generated/" + file.getName()
    )
    if (!src.exists()) return null
    val line = scala.io.Source.fromFile(src.getAbsolutePath()).getLines().next
    if (line contains "Copyright") line else null
  }

  def printLicenseComment() {
    val year = java.util.Calendar.getInstance().get(java.util.Calendar.YEAR)
    val defaultCopyright = s"// Copyright (c) $year Simon Fell"
    val originalCopyright = getOriginalCopyright(file)
    val copyRight =
      if (originalCopyright == null) defaultCopyright else originalCopyright
    w.println(copyRight)
    w.println("""///
		/// Permission is hereby granted, free of charge, to any person obtaining a
		/// copy of this software and associated documentation files (the "Software"),
		/// to deal in the Software without restriction, including without limitation
		/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
		/// and/or sell copies of the Software, and to permit persons to whom the
		/// Software is furnished to do so, subject to the following conditions
		///
		/// The above copyright notice and this permission notice shall be included
		/// in all copies or substantial portions of the Software.
		///
		/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
		/// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
		/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
		/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
		/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
		/// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
		/// THE SOFTWARE.
		///
		/// 
		/// Note: This file was generated by WSDL2ZKSforce.
		///		  see https://github.com/superfell/WSDL2ZKSforce
		///       DO NOT HAND EDIT.
		///
		/""".stripMargin('/'));
  }

  def writeFieldSerializers(
      instName: String,
      valueScope: String,
      fields: collection.Seq[ComplexTypeProperty]
  ) {
    if (fields.length == 0) return;
    val padTo = fields.map(_.serializerLength).max
    val padNamesTo = fields.map(_.elementName.length).max
    for (f <- fields)
      println(f.serializerMethod(instName, padTo, padNamesTo, valueScope))
  }
}

class BaseStubWriter(val allOperations: Seq[Operation]) {

  val operations = filterOps(allOperations);

  def filterOps(
      allOperations: Seq[Operation]
  ): Seq[Operation] = {
    return allOperations;
  }

  def writeClass() {
    writeHeader()
    writeImpl()
  }

  def referencedTypes(): Set[TypeInfo] = {
    Set(operations.map(_.types).flatten: _*)
  }

  def returnTypes(): Set[TypeInfo] = {
    val rt = Set(operations.map(_.returnType): _*)
    val ordering = Ordering.fromLessThan[TypeInfo](_.objcName > _.objcName)
    val ts = collection.immutable.TreeSet.empty[TypeInfo](ordering)
    ts ++ rt
  }

  def writeHeader() {}

  def writeImpl() {}
}

class BlockTypeDefStubWriter(allOperations: Seq[Operation])
    extends BaseStubWriter(allOperations) {

  override def writeHeader() {
    val w = new SourceWriter(
      new File(new File("output/generated"), "ZKBlockTypes.h")
    )
    w.printLicenseComment()
    for (rt <- returnTypes.filter(_.isGeneratedType()))
      w.printClassForwardDecl(rt.objcName)
    w.println()

    val pad = returnTypes.map(_.blockTypeName.length).max
    for (rt <- returnTypes.filter(_.objcName != "void"))
      printBlockTypeDef(w, rt.blockTypeName, rt.fullTypeNameForBlock, pad)

    printBlockTypeDef(w, "ZKFailWithErrorBlock", "NSError *", pad)
    printBlockTypeDef(w, "ZKCompleteVoidBlock", "void", pad)
    w.println()
    w.close()
  }

  def printBlockTypeDef(
      w: SourceWriter,
      name: String,
      returnType: String,
      pad: Integer
  ) {
    val padding = " ".padTo(pad - name.length + 1, ' ')
    val rt = if (returnType == "void") returnType else returnType + "result"
    w.println(s"typedef void (^$name)$padding(${rt});")
  }
}

class ASyncStubWriter(allOperations: Seq[Operation])
    extends BaseStubWriter(allOperations) {

  override def writeHeader() {
    val w = new SourceWriter(
      new File(new File("output/generated"), "ZKSforceBaseClient+Operations.h")
    )
    w.printLicenseComment()
    w.printImport("ZKSforceBaseClient.h")
    w.printImport("ZKBlockTypes.h")
    w.println()
    w.println("@interface ZKSforceBaseClient (AsyncOperations)")
    w.println();
    w.println(
      "/** @return true if we've performed a login request and it succeeded. */"
    )
    w.println("@property (readonly) BOOL loggedIn;")
    w.println()
    for (op <- operations) {
      w.println(op.blockMethodSignature + ";")
      w.println()
      w.println(op.fullBlockMethodSignature + ";")
      w.println()
      w.println()
    }
    w.println("@end")
    w.close()
  }

  override def writeImpl() {
    val w = new SourceWriter(
      new File(new File("output/generated"), "ZKSforceBaseClient+Operations.m")
    )
    w.printLicenseComment()
    w.printImport("ZKSforceBaseClient+Operations.h")
    w.printImport("ZKAuthenticationInfo.h")
    w.printImport("ZKErrors.h")
    w.println()
    w.println(s"""@implementation ZKSforceBaseClient (AsyncOperations)
				|
				|-(BOOL)loggedIn {
    			|	return self.authSource.sessionId.length > 0;
				|}
				|
				|-(void)execWithSession:(void(^)(NSError *sessionError))cb {
				|	if (![self loggedIn]) {
				|		cb([ZKErrors authenticationRequiredError]);
				|		return;
				|	}
    			|	[self.authSource refreshIfNeeded:^(BOOL refreshed, NSError *ex) {
        		|		if (refreshed) {
            	|			self.endpointUrl = self.authSource.instanceUrl;
        		|		}
        		|		cb(ex);
    			|	}];
				|}
				|
				|-(BOOL)handledError:(NSError *)ex queue:(dispatch_queue_t)queue failBlock:(ZKFailWithErrorBlock)failBlock {
    			|	if (ex == nil) {
        		|		return NO;
    			|	}
        		|	dispatch_async(queue, ^{ failBlock(ex); });
    			|	return YES;
				|}
				|
				|""".stripMargin('|'))
    for (op <- operations) {
      val completeBlock =
        if (op.returnType.objcName == "void") "completeBlock()"
        else s"completeBlock(result)"
      val makeResult =
        if (op.returnType.objcName == "void") ""
        else {
          if (op.requiresPrePostCallHooks()) {
            s"${op.returnType.fullTypeName}result = [self postHook_${op.name}:[self ${op.makeResultMethodName}:root]];"
          } else {
            s"${op.returnType.fullTypeName}result = [self ${op.makeResultMethodName}:root];"
          }
        }
      if (op.requiresPrePostCallHooks) {
        w.println(
          s"-(${op.returnType.fullTypeName})preHook_${op.name}${op.paramList} { return nil; }"
        )
        w.println(
          s"-(${op.returnType.fullTypeName})postHook_${op.name}:(${op.returnType.fullTypeName})r { return r; }"
        )
        w.println()
      }
      if (op.params.isEmpty) {
        w.println(s"""${op.blockMethodSignature} {
							|	[self ${op.name}WithQueue:dispatch_get_main_queue()
							|           failBlock:failBlock 
							|       completeBlock:completeBlock];
							|}
							|""".stripMargin('|'))
      } else {
        w.println(s"""${op.blockMethodSignature} {
							|	[self ${op.name}${op.callSyncParamList}
							|               queue:dispatch_get_main_queue() 
							|           failBlock:failBlock 
							|       completeBlock:completeBlock];
							|}
							|""".stripMargin('|'))
      }

      w.println(op.fullBlockMethodSignature + " {")
      w.println()
      val checkSession =
        op.inputHeaders.map(_.elementName).contains("SessionHeader")
      if (checkSession) {
        w.println(s"""|	[self execWithSession:^(NSError *sessionErr) {
							  |		if ([self handledError:sessionErr queue:callbackQueue failBlock:failBlock]) {
							  |			return;
							  |		}""".stripMargin('|'))
        w.indent()
      }
      if (op.requiresPrePostCallHooks()) {
        w.println(
          s"""|	${op.returnType.fullTypeName}shortcut = [self preHook_${op.name}${op.callSyncParamList}];
								|	if (shortcut != nil) {
								|		dispatch_async(callbackQueue, ^{ completeBlock(shortcut); });
								|		return;
								|	}""".stripMargin('|')
        )
      }
      w.println(
        s"""|	NSString *payload = [self ${op.makeEnvMethodName}${op.callSyncParamList}];
							|	[self startRequest:payload name:@"${op.name}" handler:^(ZKElement *root, NSError *err) {
							|		if (![self handledError:err queue:callbackQueue failBlock:failBlock]) {
							|			${makeResult}
							|			dispatch_async(callbackQueue, ^{ ${completeBlock}; });
							|		}
							|	}];""".stripMargin('|')
      )
      if (checkSession) {
        w.println("}];")
        w.outdent()
      }
      w.println("}")
      w.println()
    }
    w.println("@end");
    w.close()
  }
}

class BaseClientWriter(
    allOperations: Seq[Operation],
    headers: collection.Seq[ComplexTypeProperty]
) extends BaseStubWriter(allOperations) {

  override def writeHeader() {
    val w = new SourceWriter(
      new File(new File("output/generated"), "ZKSforceBaseClient.h")
    )
    w.printLicenseComment()
    w.println()
    w.printImport("ZKBaseClient.h")
    w.println()
    w.printProtocolForwardDecl("ZKAuthenticationInfo")
    w.printClassForwardDecl("ZKElement")
    for (h <- headers)
      w.printClassForwardDecl(h.propType.objcName)
    val rts = collection.immutable.TreeSet.empty[String] ++ referencedTypes
      .map(_.forwardDeclType())
      .filter(_.isGeneratedType)
      .map(_.objcName)
    for (t <- rts)
      w.printClassForwardDecl(t)
    w.println()
    w.println("@interface ZKSforceBaseClient : ZKBaseClient ")
    w.println()
    w.println("@property (strong) NSObject<ZKAuthenticationInfo> *authSource;")
    w.println()
    val padTo =
      headers.map(_.propType.propertyLengthForPaddingCalc()).max + 1
    for (h <- headers) {
      w.println(h.propertyDecl(padTo))
    }
    w.println()
    for (op <- operations) {
      w.println(op.makeEnvMethodSignature + ";")
      w.println(op.makeResultMethodSignature + ";")
      w.println()
    }
    w.println("@end")
    w.close()
  }

  override def writeImpl() {
    val w = new SourceWriter(
      new File(new File("output/generated"), "ZKSforceBaseClient.m")
    )
    w.printLicenseComment()
    w.printImport("ZKSforceBaseClient.h")
    w.printImport("ZKParser.h")
    w.printImport("ZKPartnerEnvelope.h")
    w.printImport("ZKAuthenticationInfo.h")
    w.printImport("ZKConstants.h")
    w.printImports(referencedTypes)
    w.println()
    w.println("@implementation ZKSforceBaseClient")
    w.println()
    for (op <- operations) {
      op.writeMakeEnvMethodImpl(w)
      op.writeMakeResultMethodImpl(w)
      w.println()
    }
    w.println("@end");
    w.close()
  }
}
