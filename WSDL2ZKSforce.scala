// Copyright (c) 2013-2019 Simon Fell
//
// Permission is hereby granted, free of charge, to any person obtaining a 
// copy of this software and associated documentation files (the "Software"), 
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
// and/or sell copies of the Software, and to permit persons to whom the 
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included 
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN 
// THE SOFTWARE.
//

// This is not a general purpose WSDL2Objc generator, its for generating
// classes for inclusion with ZKSforce when a new WSDL version comes out
// If you want to use ZKSforce you DO NOT HAVE TO RUN THIS, the relevant
// classes are already in ZKSforce.

import scala.xml._
import java.io._

// Helper class for generating a new source code file.
class SourceWriter(val file: File) {
	val w = new PrintWriter(file)

	def close() {
		w.close()
	}
	
	def println() {
		w.println()
	}
	
	def println(s: String) {
		w.println(s)
	}
	
	// for the collection of types, adds any import statements that would be needed.
	def printImports(types: Iterable[TypeInfo]) {
		val imports = types.map({
			_ match {
				case a:ArrayTypeInfo => if (a.componentType.isGeneratedType) a.componentType.objcName + ".h" else ""
				case t:TypeInfo      => if (t.isGeneratedType) t.objcName + ".h" else ""
			}
		})
		val ts = collection.immutable.TreeSet.empty[String]
		val its = ts ++ imports
		for (t <- its.filter(_.length > 0))
			printImport(t)
	}
	
	def printImport(f: String) {
		w.println(s"""#import "$f"""")
	}
	
	def printClassForwardDecl(c: String) {
		w.println(s"@class $c;")
	}
	
	def printProtocolForwardDecl(p: String) {
		w.println(s"@protocol $p;")
	}

	// reads the first line of the copyright from the current matching source file in the zkSforce tree, if it exists.
	private def getOriginalCopyright(file: File): String = {
		val src = new File(file.getParentFile(), "../../../zkSforce/zkSforce/generated/" + file.getName())
		if (!src.exists()) return null
		val line = scala.io.Source.fromFile(src.getAbsolutePath()).getLines().next
		if (line contains "Copyright") line else null
	}
	
	def printLicenseComment() {
		val year = java.util.Calendar.getInstance().get(java.util.Calendar.YEAR)
		val defaultCopyright = s"// Copyright (c) $year Simon Fell"
		val originalCopyright = getOriginalCopyright(file)
		val copyRight = if (originalCopyright == null) defaultCopyright else originalCopyright
		w.println(copyRight)
		w.println("""///
		/// Permission is hereby granted, free of charge, to any person obtaining a
		/// copy of this software and associated documentation files (the "Software"),
		/// to deal in the Software without restriction, including without limitation
		/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
		/// and/or sell copies of the Software, and to permit persons to whom the
		/// Software is furnished to do so, subject to the following conditions
		///
		/// The above copyright notice and this permission notice shall be included
		/// in all copies or substantial portions of the Software.
		///
		/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
		/// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
		/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
		/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
		/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
		/// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
		/// THE SOFTWARE.
		///
		/// 
		/// Note: This file was generated by WSDL2ZKSforce.
		///		  see https://github.com/superfell/WSDL2ZKSforce
		///       DO NOT HAND EDIT.
		///
		/""".stripMargin('/'));
	}
}

// Each mapping from an XML based Type to an Objective-C type we need to generate is represented by a TypeInfo
// TypeInfo has a hierarchy for different types of types (e.g. arrays, classes, etc)
class TypeInfo(val xmlName: String, val objcName: String, accessor: String, val isPointer: Boolean) {
	
	// additional comment that'll get added to a property declaration of this type.
	def propertyDeclComment(): String =  { "" }
	
	// what property flags should be used for this type.
	def propertyFlags(): String = { if (isPointer) "strong" else "assign" }
	
    // what property flags should be used for a readonly property of this type
    def readonlyPropertyFlags(): String = { if (isPointer) "weak, readonly" else "readonly" }
    
    def propertyLengthForPaddingCalc(includeFlags: Boolean) : Int = {
        var l = fullTypeName.length
        if (includeFlags) l += readonlyPropertyFlags.length
        return l
    }
    
	// full name of the objective-c type, includes * for pointer types.
	def fullTypeName(): String = { if (isPointer) objcName + " *" else objcName }
	
	// returns true if this type is one we generated rather than a system type
	def isGeneratedType(): Boolean = { objcName.startsWith("ZK") }	// TODO
	
	// returns an accessor that returns an instance of this type (when deserializing xml)
	def accessor(instanceName: String, elemName: String): String = {
		if (accessor != "") {
			s"""[$instanceName $accessor:@"$elemName"]"""
		} else {
			s""
		}
	}
	
	// returns the name of the method that is used to serialize an instance of this type
	def serializerMethodName() : String = { 
		if (objcName == "BOOL") 			"addBoolElement" 
		else if (objcName == "NSInteger") 	"addIntElement"
		else if (objcName == "double")      "addDoubleElement"
		else 								"addElement"
	}
	
	// type name for use with blocks
	def blockTypeName() : String = {
		return "ZKComplete" + objcName.substring(2) + "Block"
	}
}

// For types that are mapped to Arrays.
class ArrayTypeInfo(val componentType: TypeInfo) extends TypeInfo(componentType.xmlName, "NSArray", "", true) {

	override def propertyDeclComment(): String =  { " // of " + componentType.objcName }
	
	override def accessor(instanceName:String, elemName: String): String = {
		if (componentType.objcName == "NSString")
			s"""[$instanceName strings:@"$elemName"]"""
		else
			s"""[$instanceName complexTypeArrayFromElements:@"$elemName" cls:[${componentType.objcName} class]]"""
	}
	
	override def serializerMethodName(): String = { 
		"addElementArray"
	}
}

val reservedWords = Set("inline")

// A property of a complexType (aka Class)
class ComplexTypeProperty(elemName: String, propName: String, val propType: TypeInfo, val nillable: Boolean, val optional:Boolean) {
	
	val elementName = elemName
	val propertyName = makePropertyName(elemName, propName)

	private def makePropertyName(elemName: String, propName: String) : String = {
		val n = if (propName == "") elemName else propName
		if (reservedWords.contains(n)) "_" + n else n
	}
	
	def initializer(nameOfZKElementInstance: String): String = {
	    val zke =nameOfZKElementInstance
	    s"\tself.$propertyName = ${propType.accessor(zke, elementName)};"
	}
	
	def readImplBody(): String =  {
		s"""-(${propType.fullTypeName})$propertyName {
			|    return ${propType.accessor("self", elementName)};
			|}
			""".stripMargin('|')
	}
	
	def propertyDecl(padTypeTo: Int, readOnly: Boolean): String = {
		val f = if (readOnly) propType.readonlyPropertyFlags else propType.propertyFlags
		val comment = propType.propertyDeclComment
        val padTo = if (readOnly) padTypeTo - f.length else padTypeTo
		val td = typeDef(padTo)
		val nr = if (propertyName.startsWith("new")) " NS_RETURNS_NOT_RETAINED" else ""
		var nrc = if (nr.length > 0) "; returns an autoreleased object, doesn't follow cocoa rules for properties/method starting with 'new'" else ""
		s"@property ($f) $td$nr; $comment$nrc"
	}
	
	def ivarDecl(padTypeTo: Int): String = {
		val td = typeDef(padTypeTo)
		s"\t$td;"
	}
	
	def parameterDecl(): String = {
		s"$propertyName:(${propType.fullTypeName})$propertyName"
	}
	
	private def typeDef(padTypeTo: Int): String = {
		val t = propType.objcName.padTo(padTypeTo - (if (propType.isPointer) 1 else 0), ' ')
		val p = if (propType.isPointer) "*" else ""
		s"$t$p$propertyName"
	}
	
	override def equals(other: Any): Boolean = {
		if (!other.isInstanceOf[ComplexTypeProperty]) return false
		val r = other.asInstanceOf[ComplexTypeProperty]
		r.propertyName == propertyName && r.propType.objcName == propType.objcName
	}
	
	// return the length of the serializer method name + the length of the element name, this is used to calc the right padding for a set of properties
	def serializerLength():Integer = {
		return propType.serializerMethodName.length + elementName.length + 1
	}
	
	private def objcBool(v: Boolean): String = {
		if (v) "YES" else "NO"
	}
	
	def serializerMethod(instName: String, padTo:Integer, padNameTo:Integer, valueScope:String) : String = {
		val addMethod = propType.serializerMethodName
		val pad = " ".padTo(padTo - addMethod.length - elementName.length, ' ')
		val scope = if (valueScope.length > 0) valueScope + "." else ""
		val namePad = "".padTo(padNameTo - elementName.length, ' ')
		val extra = if (propType.serializerMethodName == "addElement") 
						s"${namePad} nillable:${objcBool(nillable).padTo(3,' ')} optional:${objcBool(optional)}"
					else
						""
		s"""\t[$instName ${propType.serializerMethodName}:@"$elementName"${pad}elemValue:$scope$propertyName$extra];"""
	}
}

object Direction extends Enumeration {
	val Serialize, Deserialize = Value
}

// For types that are mapped from ComplexTypes (aka Classes)
class ComplexTypeInfo(xmlName: String, objcName: String, xmlNode: Node, val fields: Seq[ComplexTypeProperty], baseType:TypeInfo) extends TypeInfo(xmlName, objcName, "", true) {
	
	val direction =  Direction.ValueSet.newBuilder

    def prevalidate() {
        // if we're In & Out, we need our bass classes to also be in/out
        val dir = direction.result();
		if (dir.contains(Direction.Deserialize) && dir.contains(Direction.Serialize)) {
		    if (baseType != null) {
		        baseType match {
		            case c: ComplexTypeInfo => { c.direction += Direction.Serialize; c.direction += Direction.Deserialize; c.prevalidate(); }
		        }
	        }
	    }
    }
    
	def validate(): ComplexTypeInfo = {
		val dir = direction.result()
		if (dir.contains(Direction.Deserialize) && dir.contains(Direction.Serialize)) {
		    print(s"Promoting type $xmlName to an InputOutputComplexType\n")
		    return new InputOutputComplexTypeInfo(xmlName, objcName, xmlNode, fields, baseType)
		}
        this
	}
	
	override def accessor(instanceName:String, elemName: String): String = {
		s"""[$instanceName complexTypeArrayFromElements:@"$elemName" cls:[${objcName} class]].lastObject"""
	}
	
	protected def headerImportFile(): String = { if (baseType == null) "" else baseType.objcName + ".h" }
	protected def baseClass(): String = { if (baseType == null) "" else baseType.objcName }
	protected def includeIVarDecl(): Boolean = { false }
	protected def fieldsAreReadOnly(): Boolean = { true }
	protected def implementNSCopying(): Boolean = { false }
	
	def writeHeaderFile() {
		val hfile = new File(new File("output/generated"), objcName + ".h")
		hfile.getParentFile().mkdirs()
		val h = new SourceWriter(hfile)
		h.printLicenseComment()
		h.printImport(headerImportFile)
		h.println()
		writeForwardDecls(h)
		h.println("/*")
		val pp = new PrettyPrinter(809, 2)
		h.println(pp.format(xmlNode))
		h.println("*/")
		val nscopying = if (implementNSCopying()) "<NSCopying> " else ""
		h.println(s"@interface $objcName : ${baseClass} $nscopying{");
		writeHeaderIVars(h)
		h.println("}")
		writeHeaderProperties(h)
		h.println("@end")
		h.close()
	}

	protected def writeForwardDecls(w: SourceWriter) {
		for (f <- fields.filter(_.propType.isGeneratedType))
			w.printClassForwardDecl(f.propType.objcName)
	}
	
	private def padMembersTo(includeFlags: Boolean): Int = {
 		if (fields.length == 0) 0 else fields.map(_.propType.propertyLengthForPaddingCalc(includeFlags)).max + 1
	}
	
	protected def writeHeaderIVars(w: SourceWriter) {
	}

	protected def writeHeaderProperties(w: SourceWriter) {
		val padTo = padMembersTo(fieldsAreReadOnly)
		for (f <- fields)
			w.println(f.propertyDecl(padTo, fieldsAreReadOnly))
	}
	
	protected def writeImplFileBody(w: SourceWriter) {} 
	
	protected def writeImplImports(w: SourceWriter) {}
		
	def writeImplFile() {
		val ifile = new File(new File("output/generated"), objcName + ".m")
		val w = new SourceWriter(ifile)
		w.printLicenseComment()
		w.printImport(objcName + ".h")
		writeImplImports(w)
		w.println()
		w.println(s"@implementation $objcName")
		w.println()
		writeImplFileBody(w)
		w.println("@end")
		w.close()
	}
}

def writeFieldSerializers(instName:String, valueScope:String, w:SourceWriter, fields:Seq[ComplexTypeProperty]) {
	if (fields.length == 0) return;
	val padTo = fields.map(_.serializerLength).max
	val padNamesTo = fields.map(_.elementName.length).max
	for (f <- fields)
		w.println(f.serializerMethod(instName, padTo, padNamesTo, valueScope))
}

// A ComplexType from a message input, i.e. something we'll need to be able to serialize
class InputComplexTypeInfo(xmlName: String, objcName: String, xmlNode: Node, fields: Seq[ComplexTypeProperty], baseType:TypeInfo) extends ComplexTypeInfo(xmlName, objcName, xmlNode, fields, baseType) {

	override def headerImportFile(): String = { 
		val s = super.headerImportFile
		if (s == "") "ZKXMLSerializable.h" else s
	}
	
	override def baseClass(): String = { 
		val s = super.baseClass
		if (s == "") "NSObject<ZKXMLSerializable>" else s
	}
	
	override def includeIVarDecl(): Boolean = { true }
	override def fieldsAreReadOnly(): Boolean = { false }
	
	override protected def writeImplImports(w: SourceWriter) {
		w.printImport("ZKEnvelope.h")
	}

    protected def writeExtraImpl(w: SourceWriter) {
    }
    
	override protected def writeImplFileBody(w: SourceWriter) {
		w.println("@synthesize " + fields.map(_.propertyName).mkString(", ") + ";")
        writeExtraImpl(w)
        w.println()
		w.println("-(void)serializeToEnvelope:(ZKEnvelope *)env elemName:(NSString *)elemName {")
		// if there's a baseType, then this is an extension type, and we need to serialize our type out as an xsi:type attribute
		if (baseType == null)
		    w.println("\t[env startElement:elemName];")
		else
		    w.println("\t[env startElement:elemName type:@\"" + xmlName + "\"];")
		val fieldsToSerialize = if (baseType == null) fields else (baseType.asInstanceOf[ComplexTypeInfo].fields) ++ fields
		writeFieldSerializers("env", "self", w, fieldsToSerialize)
		w.println("\t[env endElement:elemName];")
		w.println("}")
	} 
}

// A ComplexType from a message output, i.e. something we'll need to be able to deserialize
class OutputComplexTypeInfo(xmlName: String, objcName: String, xmlNode: Node, fields: Seq[ComplexTypeProperty], baseType:TypeInfo) extends ComplexTypeInfo(xmlName, objcName, xmlNode, fields, baseType) {
	
	override def headerImportFile(): String = { 
		val s = super.headerImportFile
		if (s == "") "ZKXmlDeserializer.h" else s
	}
	
	override def baseClass(): String = { 
		val s = super.baseClass
		if (s == "") "ZKXmlDeserializer" else s
	}
	
	override protected def writeImplImports(w: SourceWriter) {
		w.printImports(fields.map(_.propType))
	}
	
	protected def additionalNSCopyImpl(): String = { "" }
	 
	override protected def writeImplFileBody(w: SourceWriter) {
		if (implementNSCopying) {
			w.println(s"""-(id)copyWithZone:(NSZone *)zone {
				|    zkElement *e = [node copyWithZone:zone];
				|    $objcName *c = [[$objcName alloc] initWithXmlElement:e];
				|    ${additionalNSCopyImpl}
				|    return c;
				|}
				|
				|-(zkElement *)node {
				|	return node;
				|}
				|
				|-(BOOL)isEqual:(id)anObject {
				|	if (![anObject isKindOfClass:[$objcName class]]) return NO;
				|	return [node isEqual:[anObject node]];
				|}
				|
				|-(NSUInteger)hash {
				|	return node.hash;
				|}
				|""".stripMargin('|'))
		}
		for (f <- fields)
			w.println(f.readImplBody)
	}
}

class InputOutputComplexTypeInfo(xmlName: String, objcName: String, xmlNode: Node, fields: Seq[ComplexTypeProperty], baseType:TypeInfo) extends InputComplexTypeInfo(xmlName, objcName, xmlNode, fields, baseType) {
    
	override def baseClass(): String = { 
		if (baseType == null) "ZKXmlDeserializer<ZKXMLSerializable>" else super.baseClass()
	}
	
    override protected def writeForwardDecls(w: SourceWriter) {
		w.printImport("ZKXmlDeserializer.h")
		w.printImport("ZKParser.h")
	}
	
    override protected def writeHeaderProperties(w: SourceWriter) {
        w.println("-(instancetype)init NS_DESIGNATED_INITIALIZER;")
        w.println("-(instancetype)initWithZKXmlDeserializer:(ZKXmlDeserializer *)d NS_DESIGNATED_INITIALIZER;");
        w.println("-(instancetype)initWithXmlElement:(zkElement *)e;")
        w.println();
        super.writeHeaderProperties(w);
    }
    
    override protected def writeExtraImpl(w: SourceWriter) {
        w.println()
        w.println("-(instancetype)init {")
        w.println("    self = [super init];")
        w.println("    return self;")
        w.println("}")
        w.println()
        w.println("-(instancetype)initWithZKXmlDeserializer:(ZKXmlDeserializer *)d {")
        if (baseType == null)
            w.println("    self = [super init];")
        else
            w.println("    self = [super initWithZKXmlDeserializer:d];")
        for (f <- fields)
            w.println(f.initializer("d"));
        w.println("    return self;")
        w.println("}")
        w.println()
        w.println("-(instancetype)initWithXmlElement:(zkElement *)e {")
        w.println("    ZKXmlDeserializer *d = [[ZKXmlDeserializer alloc] initWithXmlElement:e];")
        w.println("    return [self initWithZKXmlDeserializer:d];")
        w.println("}")
    }
}

class ZKDescribeField(xmlName:String, objcName:String, xmlNode:Node, fields:Seq[ComplexTypeProperty]) extends OutputComplexTypeInfo(xmlName, objcName, xmlNode, fields, null) {
	
	override protected def implementNSCopying(): Boolean = { true }
	
	override protected def writeForwardDecls(w: SourceWriter) {
		w.printClassForwardDecl("ZKDescribeSObject")
		super.writeForwardDecls(w)
	}
	
	override protected def writeHeaderIVars(w: SourceWriter) {
		w.println("\tZKDescribeSObject *__weak sobject;")
	}
	
	override protected def writeHeaderProperties(w: SourceWriter) {
		w.println("@property (weak) ZKDescribeSObject *sobject;")
		w.println()
		super.writeHeaderProperties(w)
	}
	
	override protected def writeImplImports(w: SourceWriter) {
		w.printImport("ZKDescribeSObject.h")
		w.printImport("ZKParser.h")
		super.writeImplImports(w)
	}
	
	override protected def additionalNSCopyImpl(): String = { "c.sobject = self.sobject;" }
	
	override protected def writeImplFileBody(w: SourceWriter) {
		w.println("@synthesize sobject;")
		w.println()
		super.writeImplFileBody(w)
	}
}

class ZKDescribeSObject(xmlName:String, objcName:String, xmlNode:Node, fields:Seq[ComplexTypeProperty]) extends OutputComplexTypeInfo(xmlName, objcName, xmlNode, fields, null) {

	override def headerImportFile(): String = { "ZKDescribeGlobalSObject.h" }
	override def baseClass(): String = { "ZKDescribeGlobalSObject" }
	
	override protected def writeHeaderIVars(w: SourceWriter) {
		w.println("	NSArray 	 *fieldList;")
		w.println("	NSDictionary *fieldsByName;")
	}

	override protected def writeImplFileBody(w: SourceWriter) {
		w.println("""-(NSArray *)fields {
					|	if (fieldList == nil) {
 					|		NSArray *fa = [self complexTypeArrayFromElements:@"fields" cls:[ZKDescribeField class]];
					|		for (ZKDescribeField *f in fa)
					|			f.sobject = self;
					|		fieldList = fa;
					|	}
					|	return fieldList;
					|}
					|""".stripMargin('|'));
					
		for (f <- fields.filter(_.propertyName != "fields"))
			w.println(f.readImplBody)
	}	
}

class VoidTypeInfo() extends TypeInfo("void", "void", "", false) {
	override def accessor(instanceName:String, elemName:String) : String = { "" }
	
	override def blockTypeName() : String = {
		return "ZKCompleteVoidBlock"
	}
}

class Operation(val name: String, val description: String, val params: Seq[ComplexTypeProperty], val returnType:TypeInfo, val inputHeaders: Seq[ComplexTypeProperty] ) {
	
	def requiresPrePostCallHooks(): Boolean = {
		name == "describeGlobal" || name == "describeSObject"	
	}

	def objcSignature(): String = {
		s"-(${returnType.fullTypeName})$name${paramList}"
	}
	
	def writeMethodDecl(w: SourceWriter) {
		w.println(s"""/** $description */
					|$objcSignature DEPRECATED_MSG_ATTRIBUTE("Please use perform${name.capitalize} instead");
					|""".stripMargin('|'))
	}
	
	def writeMethodImpl(w: SourceWriter) {
		val nullValue = if (returnType.objcName == "void") "" else "nil"
		w.println(s"""/** $description */
					|$objcSignature {
					|	if (!self.authSource) return $nullValue;
					|	[self checkSession];""".stripMargin('|'))
		preCallSyncHook(w)
		w.println(s"""	NSString *payload = [self ${makeEnvMethodName}${callSyncParamList}];""")

		if (returnType.objcName == "void") {
			w.println("""|	[self sendRequest:payload name:NSStringFromSelector(_cmd) returnRoot:YES];
						 |}""".stripMargin('|'))
		} else {
			w.println(s"""|	zkElement *root = [self sendRequest:payload name:NSStringFromSelector(_cmd) returnRoot:YES];
	  					  |	${returnType.fullTypeName}result = [self ${makeResultMethodName}:root];""".stripMargin('|'))
			postCallSyncHook(w)
			w.println(s"""|	return result;
						  |}
						  |""".stripMargin('|'))
		}
	}
	
	def preCallSyncHook(w: SourceWriter) {
		if (requiresPrePostCallHooks()) {
			w.println(s"""|	${returnType.fullTypeName}shortcut = [self preHook_${name}${callSyncParamList}];
						  |	if (shortcut != nil) return shortcut;""".stripMargin('|'))
		}
	}

	def postCallSyncHook(w: SourceWriter) {
		if (requiresPrePostCallHooks()) {
			w.println(s"""	result = [self postHook_${name}:result];""")
		}
	}

	def writeMakeEnvMethodImpl(w: SourceWriter) {
		w.println(makeEnvMethodSignature() + " {")
		w.println("	ZKEnvelope *env = [[ZKPartnerEnvelope alloc] initWithSessionHeader:self.authSource.sessionId];")
		writeFieldSerializers("env", "self", w, inputHeaders.filter(_.elementName != "SessionHeader"))
		w.println(s"""|	[env moveToBody];
				      |	[env startElement:@"${name}"];""".stripMargin('|'))
		writeFieldSerializers("env", "", w, params)
		w.println(s"""|	[env endElement:@"${name}"];
					  |	return env.end;
					  |}""".stripMargin('|'))
	}

	def writeMakeResultMethodImpl(w: SourceWriter) {
		w.println(makeResultMethodSignature() + " {")
		val retStmt = returnType.accessor("deser", "result")
		if (retStmt != "") {
			w.println(s"""|	zkElement *body = [root childElement:@"Body" ns:NS_SOAP_ENV];
				|	ZKXmlDeserializer *deser = [[ZKXmlDeserializer alloc] initWithXmlElement:body.childElements[0]];
				|	return $retStmt;""".stripMargin('|'))
		} else if (returnType.objcName != "void") {
			w.println(s"""	NSAssert(NO, @"subclass is expected to override this method");""")
			w.println("	return nil;")
		}
		w.println("}")
	}

	def types():Seq[TypeInfo] = {
		returnType +: params.map(_.propType) 
	}
	
	def paramList():String = {
		if (params.length == 0) return ""
		val fp = params(0)
		val first = s":(${fp.propType.fullTypeName})${fp.propertyName}"
		if (params.length == 1) return first
		first + " " + params.tail.map(_.parameterDecl).mkString(" ")
	}
	
	// what we'd need to call the sync version of this operation, e.g. :soql or :soql foo:bar
	def callSyncParamList():String = {
		if (params.length == 0) return ""
		val fp = params(0)
		val first = s":${fp.propertyName}"
		if (params.length == 1) return first;
		first + params.tail.map(x => (" " + x.propertyName + ":" + x.propertyName)).mkString("");
	}
	
	def makeEnvMethodName():String = {
		s"""make${name.capitalize}Env"""
	}

	def makeEnvMethodSignature():String = {
		s"""-(NSString *)${makeEnvMethodName}${paramList}"""
	}

	def makeResultMethodName():String = {
		s"""make${name.capitalize}Result"""
	}

	def makeResultMethodSignature():String = {
		s"""-(${returnType.fullTypeName})${makeResultMethodName}:(zkElement *)root"""
	}

	def blockMethodSignature():String = {
		val cp = name.length + 15
		if (params.length == 0)
			s"""/** ${description} */
				|-(void) perform${name.capitalize}WithFailBlock:(ZKFailWithErrorBlock)failBlock
				|${" ".padTo(cp-13,' ')}completeBlock:(${returnType.blockTypeName})completeBlock""".stripMargin('|')
		else
			s"""/** ${description} */
				|-(void) perform${name.capitalize}${paramList}
				|${" ".padTo(cp-9,' ')}failBlock:(ZKFailWithErrorBlock)failBlock
				|${" ".padTo(cp-13,' ')}completeBlock:(${returnType.blockTypeName})completeBlock""".stripMargin('|')
	}
}

class BaseStubWriter(val allOperations: Seq[Operation]) {

	val operations = filterOps(allOperations);
	
	def filterOps(allOperations:Seq[Operation]) : Seq[Operation] = {
		return allOperations;
	}
	
	def writeClass() {
		writeHeader()
		writeImpl()
	}
	
	def referencedTypes(): Set[TypeInfo] = {
		Set(operations.map(_.types).flatten : _*)
	}
	
	def returnTypes(): Set[TypeInfo] = {
		val rt = Set(operations.map(_.returnType) : _*)
		val ordering = Ordering.fromLessThan[TypeInfo](_.objcName > _.objcName)
		val ts = collection.immutable.TreeSet.empty[TypeInfo](ordering)
		ts ++ rt
	}
	
	def writeHeader() {
		
	}
	
	def writeImpl() {
		
	}
}

class BlockTypeDefStubWriter(allOperations: Seq[Operation]) extends BaseStubWriter(allOperations) {

	override def writeHeader() {
		val w = new SourceWriter(new File(new File("output/generated"), "ZKBlockTypes.h"))
		w.printLicenseComment()
		for (rt <- returnTypes.filter(_.isGeneratedType()))
			w.printClassForwardDecl(rt.objcName)
		w.println()

		val pad = returnTypes.map(_.blockTypeName.length).max
		for (rt <- returnTypes.filter(_.objcName != "void"))
			printBlockTypeDef(w, rt.blockTypeName, rt.fullTypeName, pad)

		printBlockTypeDef(w, "ZKFailWithErrorBlock", "NSError *", pad)
		printBlockTypeDef(w, "ZKCompleteVoidBlock", "void", pad)
		w.println()
		w.close()
	}

	def printBlockTypeDef(w:SourceWriter, name:String, returnType:String, pad:Integer) {
		val padding = " ".padTo(pad - name.length + 1, ' ')
		val rt = if (returnType == "void") returnType else returnType+"result"
		w.println(s"typedef void (^$name)$padding(${rt});")
	}
}

class ASyncStubWriter(allOperations: Seq[Operation]) extends BaseStubWriter(allOperations) {

	override def writeHeader() {
		val w = new SourceWriter(new File(new File("output/generated"), "ZKSforceBaseClient+Operations.h"))
		w.printLicenseComment()
		w.printImport("ZKSforceBaseClient.h")
		w.printImport("ZKBlockTypes.h")
		w.println()
		w.println("@interface ZKSforceBaseClient (AsyncOperations)")
		w.println();
		for (op <- operations) {
			w.println(op.blockMethodSignature +";")
			w.println()
		}
		w.println("@end")
		w.close()
	}
	
	override def writeImpl() {
		val w = new SourceWriter(new File(new File("output/generated"), "ZKSforceBaseClient+Operations.m"))
		w.printLicenseComment()
		w.printImport("ZKSforceBaseClient+Operations.h")
		w.printImport("ZKErrors.h")
		w.println()
		w.println(s"""@implementation ZKSforceBaseClient (AsyncOperations)
				|
				|-(BOOL)confirmLoggedIn {
				|	return YES; // concrete impl in subclass
				|}
				|
				|-(BOOL)handledError:(NSError *)ex failBlock:(ZKFailWithErrorBlock)failBlock {
    			|	if (ex == nil) {
        		|		return NO;
    			|	}
    			|	if (failBlock != nil) {
        		|		dispatch_async(dispatch_get_main_queue(), ^{
            	|			failBlock(ex);
        		|		});
    			|	}
    			|	return YES;
				|}
				|""".stripMargin('|'))
		for (op <- operations) {
			val completeBlock = if (op.returnType.objcName == "void") "completeBlock()" else s"completeBlock(result)"
			val makeResult = if (op.returnType.objcName == "void") "" else {
				if (op.requiresPrePostCallHooks()) {
					s"${op.returnType.fullTypeName}result = [self postHook_${op.name}:[self ${op.makeResultMethodName}:root]];"
				} else {
					s"${op.returnType.fullTypeName}result = [self ${op.makeResultMethodName}:root];"
				}
			}
			if (op.requiresPrePostCallHooks) {
				w.println(s"-(${op.returnType.fullTypeName})preHook_${op.name}${op.paramList} { return nil; }")
				w.println(s"-(${op.returnType.fullTypeName})postHook_${op.name}:(${op.returnType.fullTypeName})r { return r; }")
				w.println()
			}
			w.println(op.blockMethodSignature + " {")
			w.println()
			val checkSession = op.inputHeaders.map(_.elementName).contains("SessionHeader")
			if (checkSession) {
				w.println(s"""|	if (![self confirmLoggedIn]) {
							  |		[self handledError:[ZKErrors authenticationRequiredError] failBlock:failBlock];
							  |		return;
							  |	}""".stripMargin('|'))
			}
			if (op.requiresPrePostCallHooks()) {
				w.println(s"""|	${op.returnType.fullTypeName}shortcut = [self preHook_${op.name}${op.callSyncParamList}];
								|	if (shortcut != nil) {
								|		dispatch_async(dispatch_get_main_queue(), ^{
								|				completeBlock(shortcut);
								|		});
								|		return;
								|	}""".stripMargin('|'))
			}
			w.println(s"""|	NSString *payload = [self ${op.makeEnvMethodName}${op.callSyncParamList}];
							|	[self startRequest:payload name:@"${op.name}" handler:^(zkElement *root, NSError *err) {
							|		if (![self handledError:err failBlock:failBlock]) {
							|			${makeResult}
							|			dispatch_async(dispatch_get_main_queue(), ^{
							|				${completeBlock};
							|			});
							|		}
							|	}];
							|}
							|""".stripMargin('|'))
		}
		w.println("@end");
		w.close()
	}
}

class BaseClientWriter(allOperations: Seq[Operation], headers: Seq[ComplexTypeProperty]) extends BaseStubWriter(allOperations) {

	override def writeHeader() {
		val w = new SourceWriter(new File(new File("output/generated"), "ZKSforceBaseClient.h"))
		w.printLicenseComment()
		w.println()
		w.printImport("ZKBaseClient.h")
		w.println()
		w.printProtocolForwardDecl("ZKAuthenticationInfo")
		w.printClassForwardDecl("zkElement")
		for (h <- headers)
			w.printClassForwardDecl(h.propType.objcName)
		val rts = collection.immutable.TreeSet.empty[String] ++ referencedTypes.filter(_.isGeneratedType).map(_.objcName)
		for (t <- rts)
			w.printClassForwardDecl(t)
		w.println()
		w.println("@interface ZKSforceBaseClient : ZKBaseClient ")
		w.println()
		w.println("@property (strong) NSObject<ZKAuthenticationInfo> *authSource;")
		w.println()
		val padTo = headers.map(_.propType.propertyLengthForPaddingCalc(false)).max + 1
		for (h <- headers) {
			w.println(h.propertyDecl(padTo, false))
		}
		w.println()
		for (op <- operations) {
			w.println(op.makeEnvMethodSignature + ";")
			w.println(op.makeResultMethodSignature +";")
			w.println()
		}
		w.println("@end")
		w.close()
	}
	
	override def writeImpl() {
		val w = new SourceWriter(new File(new File("output/generated"), "ZKSforceBaseClient.m"))
		w.printLicenseComment()
		w.printImport("ZKSforceBaseClient.h")
		w.printImport("ZKParser.h")
		w.printImport("ZKPartnerEnvelope.h")
		w.printImport("ZKAuthenticationInfo.h")
		w.printImport("ZKConstants.h")
		w.printImports(referencedTypes)
		w.println()
		w.println("@implementation ZKSforceBaseClient")
		w.println()
		for (op <- operations) {
			op.writeMakeEnvMethodImpl(w)
			op.writeMakeResultMethodImpl(w)
			w.println()
		}
		w.println("@end");
		w.close()
	}
}

class Schema(wsdl: Elem, typeMapping: Map[String, TypeInfo]) {
	private val complexTypeElems = createComplexTypesElems(wsdl)
	private val complexTypes = collection.mutable.Map[String, ComplexTypeInfo]()
	private val elements = createElements(wsdl)
	private val simpleTypes = createSimpleTypes(wsdl)
	private val bindingOperations = createBindingOperations(wsdl)
	private val operations = collection.mutable.MutableList[Operation]()
	private var allHeaders = collection.mutable.MutableList[ComplexTypeProperty]()
	private val VOID = new VoidTypeInfo()
	
	val messages = createMessages(wsdl)

	def addOperation(name: String, inputElemName: String, outputElemName: String, description: String) {
		val input = handleInputElement(inputElemName)
		val output = handleOutputElement(outputElemName)
		var opType = if (output.length > 0) output(0).propType else VOID
		// headers
		val bindingOp = bindingOperations(inputElemName)
		val headers = (bindingOp \ "input" \ "header").map(x => (
			handleHeader(stripPrefix((x \ "@message").text), (x \ "@part").text)))

		// some of the manually written operations have different return types to what's in the WSDL
		// so we need to fix up our metadata for that
		if (name == "describeGlobal")
			opType = new ArrayTypeInfo(getType("DescribeGlobalSObjectResult", Direction.Deserialize))
		if (name == "retrieve")
			opType = new TypeInfo("dict", "NSDictionary", "", true)
			
		operations += new Operation(name, description, input, opType, headers)
	}
	
	def handleHeader(message:String, partName: String) : ComplexTypeProperty = {
		val msg = messages(message)
		for (part <- msg \ "part") {
			if ((part \ "@name").text == partName) {
				val elmName = stripPrefix((part \ "@element").text)
				val propName = elmName(0).toLower + elmName.substring(1)
				val elm = elements(elmName)
				if (!complexTypes.contains(elmName)) {
					makeComplexType(elmName, (elm \ "complexType")(0), Direction.Serialize)
					allHeaders += new ComplexTypeProperty(elmName, propName, complexTypes(elmName), false, true);
				}
				return new ComplexTypeProperty(elmName, propName, complexTypes(elmName), false, true);
			}
		}
		return null
	}
	
	def handleInputElement(elementName: String): Seq[ComplexTypeProperty] = {
		return handleElement(elementName, Direction.Serialize)
	}
	
	def handleOutputElement(elementName: String): Seq[ComplexTypeProperty] = {
		return handleElement(elementName, Direction.Deserialize)
	}
	
	private def handleElement(elementName: String, dir: Direction.Value): Seq[ComplexTypeProperty] = {
		// walk through the element decl and build the related types.
		val element = elements(elementName)
		return (element \ "complexType" \ "sequence" \ "element").map(generateField(_, dir))
	}
	
	// some types are extensions of base types, and not found by the basic operation driven traversal
	// so we need to go through and find these. (alternatively we could just create types for all complexTypes
	// in the wsdl, think about doing that instead. The problem with that is currently different types
	// are generated for output vs input, we'd need to be able to have one base type that we can generate
	// regardless of whether its used for input or output to do that).
	def addDerivedTypes() {
		for (ct <- complexTypeElems.values) {
			val name = (ct \ "@name").text
			if (!complexTypes.contains(name)) {
				val rawBaseName = (ct \ "complexContent" \ "extension" \ "@base").text
				if (rawBaseName != null) {
					val baseName = stripPrefix(rawBaseName)
					if (complexTypes contains baseName) {
						val baseType = complexTypes(baseName)
						makeComplexType(name, baseType.direction.result.firstKey)
					}
				}	
			}
		}
		// sort headers by elementName
		allHeaders = allHeaders.sortWith(_.elementName < _.elementName)
	}
	
	def complexType(xmlName: String, dir: Direction.Value) : ComplexTypeInfo = {
		val t = complexTypes.getOrElse(xmlName, makeComplexType(xmlName, dir))
		t.direction += dir
		return t
	}
	
	def writeClientStub() {
		new ASyncStubWriter(operations).writeClass()
		new BaseClientWriter(operations, allHeaders).writeClass()
		new BlockTypeDefStubWriter(operations).writeClass()
	}
	
	def writeTypes() {
	    for ((_, ct) <- complexTypes) {
	        ct.prevalidate();
	    }
		for ((_, ct) <- complexTypes) {
		    val finalType = ct.validate();
			finalType.writeHeaderFile()
			finalType.writeImplFile()
		}
		for (h <- allHeaders)
			println("Header " + h.elementName)
	}
	
    def writeZKSforceh() {
		val w = new SourceWriter(new File(new File("output"), "ZKSforce.h"))
		w.printLicenseComment()
		val fixedImports = List("ZKSforceClient.h", "ZKSforceBaseClient+Operations.h", "ZKSObject.h", "ZKLimitInfoHeader.h", "ZKLimitInfo.h")
		for (i <- fixedImports)
			w.printImport(i)
		w.printImports(complexTypes.values)
		val extraImports = List.fromArray(new File("../zkSforce/zkSforce/extras").listFiles().filter(_.getName().contains("+")).filter(_.getName().endsWith(".h")))
		for(f <- extraImports.sortWith(_.getName().toLowerCase() < _.getName().toLowerCase()))
			w.printImport(f.getName())
		w.close()
	}
	
	private def createBindingOperations(wsdl: Elem): Map[String, Node] = {
		(wsdl \ "binding" \ "operation").map(x => ((x \ "@name").text, x)).toMap
	}
	
	private def createSimpleTypes(wsdl: Elem): Map[String, Node] = {
		val schemas = (wsdl \ "types" \ "schema" )
		for (schema <- schemas) {
			if ((schema \ "@targetNamespace").text == "urn:partner.soap.sforce.com") {
				return (schema \ "simpleType").map( x => ( (x \ "@name").text, x )).toMap
			}
		}
		return collection.immutable.Map[String, Node]()
	}
	
	private def createElements(wsdl: Elem): Map[String, Node] = {
		val schemas = (wsdl \ "types" \ "schema" )
		for (schema <- schemas) {
			if ((schema \ "@targetNamespace").text == "urn:partner.soap.sforce.com") {
				return (schema \ "element").map( x => ( (x \ "@name").text, x )).toMap
			}
		}
		return collection.immutable.Map[String, Node]()
	}
	
	private def createMessages(wsdl: Elem): Map[String, Node] = {
		(wsdl \ "message").map( x => ((x \ "@name").text, x)).toMap
	}
	
	private def createComplexTypesElems(wsdl: Elem): Map[String, Node] = {
		val schemas = (wsdl \ "types" \ "schema" )
		for (schema <- schemas) {
			if ((schema \ "@targetNamespace").text == "urn:partner.soap.sforce.com") {
				return (schema \ "complexType").map( x => ( (x \ "@name").text, x )).toMap
			}
		}
		return collection.immutable.Map[String, Node]()
	}
	
	
	private def makeObjcName(xmlName: String): String = {
		// There are some generated types that for legacy reasons we want to have a different name to the default name mapped from the wsdl
		val newNames = Map(
						// default Name		  			-> name to use instead
						"GetUserInfoResult" 			-> "ZKUserInfo",
						"Field"	  		    			-> "ZKDescribeField",
						"DescribeGlobalSObjectResult" 	-> "ZKDescribeGlobalSObject",
						"DescribeSObjectResult"			-> "ZKDescribeSObject"
						)
		return newNames.getOrElse(xmlName, "ZK" + xmlName.capitalize)
	}

	private def defaultComplexType(dir: Direction.Value, xmlName: String, objcName: String, ct: Node, fields: Seq[ComplexTypeProperty], baseType: TypeInfo): ComplexTypeInfo = {
		if (objcName == "ZKDescribeField")
			new ZKDescribeField(xmlName, objcName, ct, fields)

		else if (objcName == "ZKDescribeSObject") {
			val dg = complexType("DescribeGlobalSObjectResult", Direction.Deserialize);
			val childFields = fields.filter(!dg.fields.contains(_))
			new ZKDescribeSObject(xmlName, objcName, ct, childFields)
		}
		
		else if (dir == Direction.Serialize)
			new InputComplexTypeInfo(xmlName, objcName, ct, fields, baseType)

		else
			new OutputComplexTypeInfo(xmlName, objcName, ct, fields, baseType)
	}
	
	private def makeComplexType(xmlName: String, dir: Direction.Value): ComplexTypeInfo = {
		val ct = complexTypeElems(xmlName)
		makeComplexType(xmlName, ct, dir)
	}
	
	private def makeComplexType(xmlName: String, complexTypeNode: Node, dir: Direction.Value): ComplexTypeInfo = {
		val objcName = makeObjcName(xmlName)
		// we insert a temporary version of the complexType to handle recursive definitions
		complexTypes(xmlName) = new ComplexTypeInfo(xmlName, objcName, complexTypeNode, List(), null)
		val base:String = stripPrefix((complexTypeNode \ "complexContent" \ "extension" \ "@base").text)
		val baseType:TypeInfo = if (base.length > 0) complexType(base, dir) else null
		val sequence = if (base.length > 0) (complexTypeNode \ "complexContent" \ "extension" \ "sequence") else (complexTypeNode \ "sequence")
		val fields = (sequence \ "element").map( x => generateField(x, dir) )
		val i = defaultComplexType(dir, xmlName, objcName, complexTypeNode, fields, baseType)
		i.direction += dir
		complexTypes(xmlName) = i
		return i
	}

	private def generateField(field: Node, dir: Direction.Value): ComplexTypeProperty = {
		val max = (field \ "@maxOccurs").text
		val array = (max != "" && max != "1")
		val xmlt = elementType(field)
		val name = (field \ "@name").text
		val singleType = getType(xmlt, dir)
		val t = if (array) new ArrayTypeInfo(singleType) else singleType
		val optional = (field \ "@minOccurs").text == "0"
		val nillable = (field \ "@nillable").text == "true"
		new ComplexTypeProperty(name, name, t, nillable, optional)
	}

	private def getType(xmlName: String, dir: Direction.Value): TypeInfo = {
		if (typeMapping contains xmlName) return typeMapping(xmlName)
		if (complexTypes contains xmlName) return complexType(xmlName, dir)
		if (simpleTypes contains xmlName) return typeMapping("string")	// are all simple types string extentions/restrictions ?
		makeComplexType(xmlName, dir)	// no where else, assume its a complexType we haven't processed yet
	}
	
	private def elementType(e: Node): String = {
		stripPrefix((e \ "@type").text)
	}
}

def stripPrefix(v: String): String = {
	val c = v.indexOf(':')
	if (c == -1) v else v.substring(c+1)
}

object WSDL2ZKSforce {
	def main(args: Array[String]) {
		// class TypeInfo(val xmlName: String, val objcName: String, accessor: String, val isPointer: Boolean)
		// accessor is the accessor method on the ZKXmlDeserializer class
		val types = Map(
					"string" 		-> new TypeInfo("string", 		"NSString",  	"string",  		true),
					"int" 	 		-> new TypeInfo("int",    		"NSInteger", 	"integer", 		false),
					"long"			-> new TypeInfo("long",			"int64_t",		"int64",		false),
					"double"		-> new TypeInfo("double",		"double",		"double",		false),
					"boolean"		-> new TypeInfo("boolean", 		"BOOL", 	 	"boolean", 		false),
					"ID"	 		-> new TypeInfo("ID",			"NSString",  	"string",  		true),
					"sObject"		-> new TypeInfo("sObject", 		"ZKSObject", 	"sObject",  	true),
					"QueryResult"   -> new TypeInfo("QueryResult",  "ZKQueryResult","queryResult",	true),
					"dateTime"		-> new TypeInfo("dateTime",		"NSDate",  	 	"dateTime", 	true),
					"date"   		-> new TypeInfo("date",    		"NSDate",    	"date",     	true),
					"time"   		-> new TypeInfo("time",    		"NSDate",    	"time",     	true),
					"base64Binary" 	-> new TypeInfo("base64Binary", "NSData", 	 	"blob",     	true),
					"anyType"		-> new TypeInfo("anyType",		"ZKXsdAnyType",	"anyType",		true)
					)
					
		val wsdl = XML.loadFile("./partner.wsdl")
		val schema = new Schema(wsdl, types)
		
		for (op <- (wsdl \ "portType" \ "operation")) {
			val opName = (op \ "@name").text
			val inMsg  = schema.messages(stripPrefix((op \ "input" \ "@message").text))
			val outMsg = schema.messages(stripPrefix((op \ "output" \ "@message").text))
			val inElm  = stripPrefix((inMsg \ "part" \ "@element").text)
			val outElm = stripPrefix((outMsg \ "part" \ "@element").text)
			val desc   = (op \ "documentation").text
			println(opName.padTo(40, ' ') + inElm.padTo(40, ' ' ) + outElm)
			schema.addOperation(opName, inElm, outElm, desc)
		}
		// currently we need to explicitly add this, as its not reachable via just traversing the schema
		schema.complexType("address", Direction.Deserialize).direction += Direction.Serialize
		
		schema.addDerivedTypes()
		schema.writeClientStub()
		schema.writeTypes()
		schema.writeZKSforceh()
  	}
}

WSDL2ZKSforce.main(args)
